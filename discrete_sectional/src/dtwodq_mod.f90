module dtwodq_mod
    
    use preci, wp => dp
    implicit none

contains

    subroutine DTWODQ(F,AA,BB,G,H,TOL,ERE,IR_0,RESULT,ERROR)
         
!***BEGIN PROLOGUE  TWODQ
!***DATE WRITTEN   840518   (YYMMDD)
!***REVISION DATE  840518   (YYMMDD)
!***CATEGORY NO.  D1I
!***KEYWORDS  QUADRATURE,TWO DIMENSIONAL,ADAPTIVE,CUBATURE
!***AUTHOR KAHANER,D.K.,N.B.S.
!          RECHARD,O.W.,N.B.S.
!          BARNHILL,ROBERT,UNIV. OF UTAH
!***PURPOSE  To compute the two-dimensional integral of a function
!            F over a region consisting of N triangles.
!***DESCRIPTION

!   This subroutine computes the two-dimensional integral of a
!   function F over a region consisting of N triangles.
!   A total error estimate is obtained and compared with a
!   tolerance - TOL - that is provided as input to the subroutine.
!   The error tolerance is treated as either relative or absolute
!   depending on the input value of IFLAG.  A 'Local Quadrature
!   Module' is applied to each input triangle and estimates of the
!   total integral and the total error are computed.  The local
!   quadrature module is either subroutine LQM0 or subroutine
!   LQM1 and the choice between them is determined by the
!   value of the input variable ICLOSE.

!   If the total error estimate exceeds the tolerance, the triangle
!   with the largest absolute error is divided into two triangles
!   by a median to its longest side.  The local quadrature module
!   is then applied to each of the subtriangles to obtain new
!   estimates of the integral and the error.  This process is
!   repeated until either (1) the error tolerance is satisfied,
!   (2) the number of triangles generated exceeds the input
!   parameter MAXTRI, (3) the number of integrand evaluations
!   exceeds the input parameter MEVALS, or (4) the subroutine
!   senses that roundoff error is beginning to contaminate
!   the result.

!   The user must specify MAXTRI, the maximum number of triangles
!   in the final triangulation of the region, and provide two
!   storage arrays - DATA and IWORK - whose sizes are at least
!   9*MAXTRI and 2*MAXTRI respectively.  The user must also
!   specify MEVALS, the maximum number of function evaluations
!   to be allowed.  This number will be effective in limiting
!   the computation only if it is less than 94*MAXTRI when LQM1
!   is specified or 56*MAXTRI when LQM0 is specified.

!   After the subroutine has returned to the calling program
!   with output values, it can be called again with a smaller
!   value of TOL and/or a different value of MEVALS.  The tolerance
!   can also be changed from relative to absolute
!   or vice-versa by changing IFLAG.  Unless
!   the parameters NU and ND are reset to zero the subroutine
!   will restart with the final set of triangles and output
!   values from the previous call.

!   ARGUMENTS:

!   F function subprogram defining the integrand F(u,v);
!     the actual name for F needs to be declared EXTERNAL
!     by the calling program.

!   N the number of input triangles.

!   X a 3 by N array containing the abscissae of the vertices
!     of the N triangles.

!   Y a 3 by N array containing the ordinates of the vertices
!     of the N triangles

!   TOL the desired bound on the error.  If IFLAG=0 on input,
!       TOL is interpreted as a bound on the relative error;
!       if IFLAG=1, the bound is on the absolute error.

!   ICLOSE an integer parameter that determines the selection
!          of LQM0 or LQM1.  If ICLOSE=1 then LQM1 is used.
!          Any other value of ICLOSE causes LQM0 to be used.
!          LQM0 uses function values only at interior points of
!          the triangle.  LQM1 is usually more accurate than LQM0
!          but involves evaluating the integrand at more points
!          including some on the boundary of the triangle.  It
!          will usually be better to use LQM1 unless the integrand
!          has singularities on the boundary of the triangle.

!   MAXTRI The maximum number of triangles that are allowed
!          to be generated by the computation.

!   MEVALS  The maximum number of function evaluations allowed.

!   RESULT output of the estimate of the integral.

!   ERROR output of the estimate of the absolute value of the
!         total error.

!   NU an integer variable used for both input and output.   Must
!      be set to 0 on first call of the subroutine.  Subsequent
!      calls to restart the subroutine should use the previous
!      output value.

!   ND an integer variable used for both input and output.  Must
!      be set to 0 on first call of the subroutine.  Subsequent
!      calls to restart the subroutine should use the previous
!      output value.

!   NEVALS  The actual number of function evaluations performed.

!   IFLAG on input:
!        IFLAG=0 means TOL is a bound on the relative error;
!        IFLAG=1 means TOL is a bound on the absolute error;
!        any other input value for IFLAG causes the subroutine
!        to return immediately with IFLAG set equal to 9.

!        on output:
!        IFLAG=0 means normal termination;
!        IFLAG=1 means termination for lack of space to divide
!                another triangle;
!        IFLAG=2 means termination because of roundoff noise
!        IFLAG=3 means termination with relative error <=
!                5.0* machine epsilon;
!        IFLAG=4 means termination because the number of function
!                evaluations has exceeded MEVALS.
!        IFLAG=9 means termination because of error in input flag

!   DATA a one dimensional array of length >= 9*MAXTRI
!        passed to the subroutine by the calling program.  It is
!        used by the subroutine to store information
!        about triangles used in the quadrature.

!   IWORK  a one dimensional integer array of length >= 2*MAXTRI
!          passed to the subroutine by the calling program.
!          It is used by the subroutine to store pointers
!          to the information in the DATA array.


!   The information for each triangle is contained in a nine word
!   record consisting of the error estimate, the estimate of the
!   integral, the coordinates of the three vertices, and the area.
!   These records are stored in the DATA array
!   that is passed to the subroutine.  The storage is organized
!   into two heaps of length NU and ND respectively.  The first heap
!   contains those triangles for which the error exceeds
!   epsabs*a/ATOT where epsabs is a bound on the absolute error
!   derived from the input tolerance (which may refer to relative
!   or absolute error), a is the area of the triangle, and ATOT
!   is the total area of all triangles.  The second heap contains
!   those triangles for which the error is less than or equal to
!   epsabs*a/ATOT.  At the top of each heap is the triangle with
!   the largest absolute error.

!   Pointers into the heaps are contained in the array IWORK.
!   Pointers to the first heap are contained
!   between IWORK(1) and IWORK(NU).  Pointers to the second
!   heap are contained between IWORK(MAXTRI+1) and
!   IWORK(MAXTRI+ND).  The user thus has access to the records
!   stored in the DATA array through the pointers in IWORK.
!   For example, the following two do loops will print out
!   the records for each triangle in the two heaps:

!     do 10 I=1,NU
!       PRINT*,(DATA(IWORK(I)+J),J=0,8)
!    10  continue
!     do 20 I=1,ND
!       PRINT*,(DATA(IWORK(MAXTRI+I)+J),J=0,8
!    20  continue

!   When the total number of triangles is equal to
!   MAXTRI, the program attempts to remove a triangle from the
!   bottom of the second heap and continue.  If the second heap
!   is empty, the program returns with the current estimates of
!   the integral and the error and with IFLAG set equal to 1.
!   Note that in this case the actual number of triangles
!   processed may exceed MAXTRI and the triangles stored in
!   the DATA array may not constitute a complete triangulation
!   of the region.

!   The following sample program will calculate the integral of
!   cos(x+y) over the square (0.,0.),(1.,0.),(1.,1.),(0.,1.) and
!   print out the values of the estimated integral, the estimated
!   error, the number of function evaluations, and IFLAG.

!     real (wp) X(3,2),Y(3,2),DATA(450),RES,ERR
!     integer IWORK(100),NU,ND,NEVALS,IFLAG
!     EXTERNAL F
!     X(1,1)=0.
!     Y(1,1)=0.
!     X(2,1)=1.
!     Y(2,1)=0.
!     X(3,1)=1.
!     Y(3,1)=1.
!     X(1,2)=0.
!     Y(1,2)=0.
!     X(2,2)=1.
!     Y(2,2)=1.
!     X(3,2)=0.
!     Y(3,2)=1.
!     NU=0
!     ND=0
!     IFLAG=1
!     CALL TWODQ(F,2,X,Y,1.E-04,1,50,4000,RES,ERR,NU,ND,
!    *  NEVALS,IFLAG,DATA,IWORK)
!     PRINT*,RES,ERR,NEVALS,IFLAG
!     END
!     FUNCTION F(X,Y)
!     F=COS(X+Y)
!     return 
!     END

!***REFERENCES  (NONE)

!***OUTINES CALLED  HINITD,HINITU,HPACC,HPDEL,HPINS,LQM0,LQM1,
!                    TRIDV,R1MACH
!***END PROLOGUE  TWODQ

    implicit none

    integer :: n,iflag,nevals,iclose,nu,nd,mevals,maxtri
    integer, dimension(200) :: iwork
    real (wp) :: F,tol,result,error
    real (wp), dimension(3,2) :: x,y
    real (wp), dimension(900) :: data
    real (wp) :: AA,BB,G,H,ERE
    integer :: IR_0
    integer :: rndcnt
    logical :: full
    !logical :: GREATR
    real (wp) :: dat05
    real (wp) :: a,r,e,epsabs,EMACH,ATOT,fadd,newres,newerr
    real (wp), dimension(3) :: u,v
    real (wp), dimension(9) :: node,node1,node2
    save ATOT
    !external F,GREATR
    external F
    external G,H
    integer :: i, j
          
    EMACH = R1MACH(4)
          
    N = 2
    X(1,1) = AA
    Y(1,1) = G(AA)
    X(2,1) = BB
    Y(2,1) = G(BB)
    X(3,1) = BB
    Y(3,1) = H(BB)
    X(1,2) = AA
    Y(1,2) = G(AA)
    X(2,2) = BB
    Y(2,2) = H(BB)
    X(3,2) = AA
    Y(3,2) = H(AA)
    NU = 0
    ND = 0
    IFLAG = 1
    ICLOSE = 1
    MAXTRI = 100
    MEVALS = 8000
          

!      If heaps are empty, apply LQM to each input triangle and
!      place all of the data on the second heap.

    if((nu+nd) == 0) then
        call HINITU(maxtri,9,nu,iwork)
        call HINITD(maxtri,9,nd,iwork(maxtri+1))
        ATOT=0.0
        result=0.0
        error=0.0
        rndcnt=0
        nevals=0
        do i=1,n
            do j=1,3
                u(j)=x(j,i)
                v(j)=y(j,i)
            end do
            a=0.5*abs(u(1)*v(2)+u(2)*v(3)+u(3)*v(1) &
            -u(1)*v(3)-u(2)*v(1)-u(3)*v(2))
            ATOT=ATOT+a
            if(iclose == 1) then
                call LQM1(f,u,v,r,e)
                nevals=nevals+47
            else
                call LQM0(f,u,v,r,e)
                nevals=nevals+28
            end if
            result=result+r
            error=error+e
            node(1)=e
            node(2)=r
            node(3)=x(1,i)
            node(4)=y(1,i)
            node(5)=x(2,i)
            node(6)=y(2,i)
            node(7)=x(3,i)
            node(8)=y(3,i)
            node(9)=a
            call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node,GREATR)
        end do
    end if

!      Check that input tolerance is consistent with
!      machine epsilon.

    if(iflag == 0) then
        if(tol <= 5.0*EMACH) then
            tol=5.0*EMACH
            fadd=3
        else
            fadd=0
        end if
        epsabs=tol*abs(result)
    else if(iflag == 1) then
        if(tol <= 5.0*EMACH*abs(result)) then
            epsabs=5.0*EMACH*abs(result)
        else
            fadd=0
            epsabs=tol
        end if
    else
        iflag=9
        return
    end if

!      Adjust the second heap on the basis of the current
!      value of epsabs.

    2 if(nd == 0) go to 40
    j=nd
    3 if(j == 0) go to 40
    call HPACC(maxtri,9,data,nd,iwork(maxtri+1),node,j)
    if(node(1) > epsabs*node(9)/ATOT) then
        call HPINS(maxtri,9,data,nu,iwork,node,GREATR)
        call HPDEL(maxtri,9,data,nd,iwork(maxtri+1),GREATR,j)
        if(j > nd) j=j-1
    else
        j=j-1
    end if
    go to 3

!      Beginning of main loop from here to end

    40 if(nevals >= mevals) then
        iflag=4
        return
    end if
    if(error <= epsabs) then
        if(iflag == 0) then
            if(error <= abs(result)*tol) then
                iflag=fadd
                return
            else
                epsabs=abs(result)*tol
                go to 2
            end if
        else
            if(error <= tol) then
                iflag=0
                return
            else if(error <= 5.0*EMACH*abs(result)) then
                iflag=3
                return
            else
                epsabs=5.0*EMACH*abs(result)
                go to 2
            end if
        end if
    end if

!      If there are too many triangles and second heap
!      is not empty remove bottom triangle from second
!      heap.  If second heap is empty return with iflag
!      set to 1 or 4.

    if((nu+nd) >= maxtri) then
        full= .TRUE. 
        if(nd > 0) then
            iwork(nu+1)=iwork(maxtri+nd)
            nd=nd-1
        else
            iflag=1
            return
        end if
    else
        full= .FALSE. 
    end if

!      Find triangle with largest error, divide it in
!      two, and apply LQM to each half.

    if(nd == 0) then
        call HPACC(maxtri,9,data,nu,iwork,node,1)
        call HPDEL(maxtri,9,data,nu,iwork,GREATR,1)
    else if(nu == 0) then
        call HPACC(maxtri,9,data,nd,iwork(maxtri+1),node,1)
        call HPDEL(maxtri,9,data,nd,iwork(maxtri+1),GREATR,1)
    else if(data(iwork(1)) >= data(iwork(maxtri+1))) then
        if(full) iwork(maxtri+nd+2)=iwork(nu)
        call HPACC(maxtri,9,data,nu,iwork,node,1)
        call HPDEL(maxtri,9,data,nu,iwork,GREATR,1)
    else
        if(full) iwork(nu+2)=iwork(maxtri+nd)
        call HPACC(maxtri,9,data,nd,iwork(maxtri+1),node,1)
        call HPDEL(maxtri,9,data,nd,iwork(maxtri+1),GREATR,1)
    end if
    dat05 = 0.5
    call tridv(node,node1,node2,dat05,1)
    do 60 j=1,3
        u(j)=node1(2*j+1)
        v(j)=node1(2*j+2)
    60 end do
    if(iclose == 1) then
        call LQM1(f,u,v,node1(2),node1(1))
        nevals=nevals+47
    else
        call LQM0(f,u,v,node1(2),node1(1))
        nevals=nevals+28
    end if
    do 70 j=1,3
        u(j)=node2(2*j+1)
        v(j)=node2(2*j+2)
    70 end do
    if(iclose == 1) then
        call LQM1(f,u,v,node2(2),node2(1))
        nevals=nevals+47
    else
        call LQM0(f,u,v,node2(2),node2(1))
        nevals=nevals+28
    end if
    newerr=node1(1)+node2(1)
    newres=node1(2)+node2(2)
    if(newerr > 0.99*node(1)) then
        if(abs(node(2)-newres) <= 1.E-04*abs(newres)) rndcnt=rndcnt+1
    end if
    result=result-node(2)+newres
    error=error-node(1)+newerr
    if(node1(1) > node1(9)*epsabs/ATOT) then
        call HPINS(maxtri,9,data,nu,iwork,node1,GREATR)
    else
        call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node1,GREATR)
    end if
    if(node2(1) > node2(9)*epsabs/ATOT) then
        call HPINS(maxtri,9,data,nu,iwork,node2,GREATR)
    else
        call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node2,GREATR)
    end if
    if(rndcnt >= 20) then
        iflag=2
        return
    end if
    if(iflag == 0) then
        if(epsabs < 0.5*tol*abs(result)) then
            epsabs=tol*abs(result)
            j=nu
            5 if(j == 0) go to 40
            call HPACC(maxtri,9,data,nu,iwork,node,j)
            if(node(1) <= epsabs*node(9)/ATOT) then
                call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node,GREATR)
                call HPDEL(maxtri,9,data,nu,iwork,GREATR,j)
                if(j > nu) j=j-1
            else
                j=j-1
            end if
            go to 5
        end if
    end if
    go to 40


    end subroutine DTWODQ



    function GREATR(A,B,NWDS)
    
    implicit none

    logical :: GREATR
    integer :: NWDS
    real (wp), dimension(NWDS) :: A, B

    GREATR= A(1) > B(1)
    return

    end function GREATR


    subroutine HINITD(NMAX,NWDS,N,T)
!   PURPOSE
!         THIS ROUTINE INITIALIZES THE HEAP PROGRAMS WITH T(NMAX)
!         POINTING TO THE TOP OF THE HEAP.
!         IT IS CALLED ONCE AT THE START OF EACH NEW CALCULATION.
!   INPUT
!         NMAX=MAXIMUM NUMBER OF NODES ALLOWED BY USER
!         NWDS=NUMBER OF WORDS PER NODE
!   OUTPUT
!         N=CURRENT NUMBER OF NODES IN HEAP = 0.
!         T=INTEGER ARRAY OF POINTERS TO POTENTIAL HEAP NODES.

    implicit none

    integer, dimension(1) :: T
    integer :: NMAX, NWDS, N, I

    do I=1,NMAX
        T(I)=(NMAX-I)*NWDS+1
    end do
    N=0
    return

    end subroutine HINITD


    subroutine HINITU(NMAX,NWDS,N,T)
!        H E A P  PACKAGE
!          A COLLECTION OF PROGRAMS WHICH MAINTAIN A HEAP DATA
!          STRUCTURE.  BY CALLING THESE SUBROUTINES IT IS POSSIBLE TO
!          INSERT, DELETE, AND ACCESS AN EXISTING HEAP OR TO BUILD A
!          NEW HEAP FROM AN UNORDERED COLLECTION OF NODES. THE HEAP
!          FUNCTION IS AN ARGUMENT TO THE SUBROUTINES ALLOWING VERY
!          GENERAL ORGANIZATIONS.
!            THE USER MUST DECIDE ON THE MAXIMUM NUMBER OF NODES
!          ALLOWED AND DIMENSION THE real (wp) ARRAY DATA AND THE INTEGER
!          ARRAY T USED INTERNALLY BY THE PACKAGE.  THESE VARIABLES ARE
!          THEN PASSED THROUGH THE CALL SEQUENCE BETWEEN THE HEAP
!          PROGRAMS BUT ARE NOT IN GENERAL ACCESSED BY THE USER.  HE
!          MUST ALSO PROVIDE A HEAP FUNCTION WHOSE NAME MUST BE INCLUD-
!          ED IN AN EXTERNAL STATEMENT IN THE USER PROGRAM WHICH CALLS
!          THE HEAP SUBROUTINES.  TWO SIMPLE HEAP FUNCTIONS ARE
!          PROVIDED WITH THE PACKAGE.


!   PURPOSE
!         THIS ROUTINE INITIALIZES THE HEAP PROGRAMS WITH T(1)
!         POINTING TO THE TOP OF THE HEAP.
!         IT IS CALLED ONCE AT THE START OF EACH NEW CALCULATION
!   INPUT
!         NMAX = MAXIMUM NUMBER OF NODES ALLOWED BY USER.
!         NWDS = NUMBER OF WORDS PER NODE
!   OUTPUT
!         N = CURRENT NUMBER OF NODES IN HEAP = 0.
!         T = integer ARRAY OF POINTERS TO POTENTIAL HEAP NODES.

    implicit none

    integer, dimension(1) :: T
    integer :: NMAX, NWDS, N, I

    do I=1,NMAX
        T(I)=(I-1)*NWDS+1
    end do
    N = 0
    return

    end subroutine HINITU


    subroutine HPACC(NMAX,NWDS,DATA,N,T,XNODE,K)

!   PURPOSE
!          TO ACCESS THE K-TH NODE OF THE HEAP,
!          1 .LE. K .LE. N .LE. NMAX
!   INPUT
!        NMAX = MAXIMUM NUMBER OF NODES ALLOWED BY USER.
!        DATA = WORK AREA FOR STORING NODES.
!        N = CURRENT NUMBER OF NODES IN THE HEAP.
!        T = integer ARRAY OF POINTERS TO HEAP NODES.
!        XNODE = A real (wp) ARRAY, NWDS WORDS LONG, IN WHICH NODAL IN-
!          FORMATION WILL BE INSERTED.
!        K = THE INDEX OF THE NODE TO BE FOUND AND INSERTED INTO
!                XNODE.

!   OUTPUT
!        XNODE =  A real (wp) ARRAY.    CONTAINS IN XNODE(1),...,XNODE(NWDS)
!          THE ELEMENTS OF THE K-TH NODE.

    implicit none

    real (wp), dimension(1) :: DATA, XNODE
    integer, dimension(1) :: T
    integer :: NMAX, NWDS, N, K, I, IPJ, J

    if (K < 1 .OR. K > N .OR. N > NMAX) return
    J=T(K)-1
    do I=1,NWDS
        IPJ=I+J
        XNODE(I)=DATA(IPJ)
    end do
    return

    end subroutine HPACC


    subroutine HPBLD(NMAX,NWDS,DATA,N,T,HPFUN)

!   PURPOSE
!          BUILDS A HEAP, IN  T , FROM AN ARRAY OF  N  ELEMENTS
!            IN DATA, WHICH ARE SPACED NWDS APART.
!            AT CONCLUSION OF CALCULATION  THE TOP SATISFIES
!            HPFUN(TOP,SON) = .TRUE. FOR ANY SON.
!          USES subroutine HPGRO BY FEEDING IT ONE ELEMENT OF
!          THE ARRAY AT A TIME.

!   INPUT
!         NMAX = MAXIMUN NUMBER OF NODES ALLOWED BY USER.
!         NWDS = NUMBER OF WORDS PER NODE.
!         DATA = WORK AREA IN WHICH THE NODES ARE STORED.
!         N = CURRENT NUMBER OF NODES.
!         T = integer ARRAY OF POINTERS TO HEAP NODES.
!         HPFUN = NAME OF USER WRITTEN FUNCTION TO DETERMINE TOP NODE.
!   OUTPUT
!         DATA = WORK AREA IN WHICH THE NODES ARE STORED.
!         T = integer ARRAY OF POINTERS TO HEAP NODES.
!              IN PARTICULAR T(1) POINTS TO THE TOP.

    implicit none

    external HPFUN
    logical :: HPFUN
    real (wp), dimension(1) :: DATA
    integer, dimension(1) :: T
    integer :: NMAX, NWDS, N, INDEX

    if (NMAX < N) return 
    INDEX = N/2
    1 continue
    if ( INDEX == 0) return 
    call HPGRO(NMAX,NWDS,DATA,N,T,HPFUN,INDEX)
    INDEX = INDEX-1
    GO TO 1

    end subroutine HPBLD


    subroutine HPDEL(NMAX,NWDS,DATA,N,T,HPFUN,K)

!   PURPOSE
!          DELETE K-TH ELEMENT OF HEAP.  RESULTING TREE IS REHEAPED.
!   INPUT
!         NMAX = MAXIMUN NUMBER OF NODES ALLOWED BY USER.
!         NWDS = NUMBER OF WORDS PER NODE.
!         DATA = WORK AREA IN WHICH THE NODES ARE STORED.
!        N = CURRENT NUMBER OF NODES.
!        T = integer ARRAY OF POINTERS TO NODES.
!         HPFUN = NAME OF USER WRITTEN FUNCTION TO DETERMINE TOP NODE.
!         K = INDEX OF NODE TO BE DELETED
!   OUTPUT
!         N = UPDATED NUMBER OF NODES.
!         T = UPDATED integer POINTER ARRAY TO NODES.

    implicit none

    external HPFUN
    logical :: HPFUN
    real (wp), dimension(1) :: DATA
    integer, dimension(1) :: T
    integer :: NMAX, NWDS, N, K, IL, IR, JUNK, KDEL, KHALVE

    if (N == 0) return 
    if (K == N) then
        N=N-1
        return 
    end if
    KDEL=K
    JUNK=T(KDEL)
    T(KDEL)=T(N)
    T(N)=JUNK
    N=N-1
    10 if (KDEL == 1) then
        CALL HPGRO(NMAX,NWDS,DATA,N,T,HPFUN,KDEL)
        return 
    else
        KHALVE=KDEL/2
        IL=T(KHALVE)
        IR=T(KDEL)
        if (HPFUN(DATA(IL),DATA(IR),NWDS)) then
            CALL HPGRO(NMAX,NWDS,DATA,N,T,HPFUN,KDEL)
            return 
        else
            T(KHALVE)=IR
            T(KDEL)=IL
            KDEL=KHALVE
        end if
    end if
    GO TO 10

    end subroutine HPDEL


    subroutine HPGRO(NMAX,NWDS,DATA,N,T,HPFUN,I)

!   PURPOSE
!          FORMS A HEAP OUT OF A TREE. USED PRIVATELY BY HPBLD.
!          THE TOP OF THE TREE IS STORED IN LOCATION T(I).
!          FIRST SON IS IN LOCATION T(2I), NEXT SON
!          IS IN LOCATION T(2I+1).
!          THIS PROGRAM ASSUMES EACH BRANCH OF THE TREE IS A HEAP.

    implicit none

    logical :: HPFUN
    real (wp), dimension(1) :: DATA
    integer, dimension(1) :: T
    integer :: NMAX, NWDS, N, I, IL, IR, ITEMP, J, K

    if (N > NMAX) return 

    K=I
    1 J=2*K

!          TEST IF ELEMENT IN J TH POSITION IS A LEAF.

    if ( J > N ) return 

!          IF THERE IS MORE THAN ONE SON, FIND WHICH SON IS SMALLEST.

    if ( J == N ) GO TO 2
    IR=T(J)
    IL=T(J+1)
    if (HPFUN(DATA(IL),DATA(IR),NWDS)) J=J+1

!          IF A SON IS LARGER THAN FATHER, INTERCHANGE
!          THIS DESTROYS HEAP PROPERTY, SO MUST RE-HEAP REMAINING
!          ELEMENTS

    2 continue
    IL=T(K)
    IR=T(J)
    if (HPFUN(DATA(IL),DATA(IR),NWDS)) return 
    ITEMP=T(J)
    T(J)=T(K)
    T(K)=ITEMP
    K=J
    GO TO 1
    end subroutine HPGRO


    subroutine HPINS(NMAX,NWDS,DATA,N,T,XNODE,HPFUN)

!   PURPOSE
!         THIS ROUTINE INSERTS A NODE INTO AN ALREADY EXISTING HEAP.
!             THE RESULTING TREE IS RE-HEAPED.

!   INPUT
!         NMAX = MAXIMUM NUMBER OF NODES ALLOWED BY USER.
!         NWDS = NUMBER OF WORDS PER NODE.
!         DATA = WORK AREA FOR STORING NODES.
!         N = CURRENT NUMBER OF NODES IN THE TREE.
!         T = integer ARRAY OF POINTERS TO HEAP NODES.
!         XNODE = A real (wp) ARRAY, NWDS WORDS LONG, WHICH
!                CONTAINS THE NODAL INFORMATION TO BE INSERTED.
!         HPFUN = NAME OF USER WRITTEN FUNCTION TO DETERMINE
!                THE TOP NODE.
!   OUTPUT
!         DATA = WORK AREA WITH NEW NODE INSERTED.
!         N = UPDATED NUMBER OF NODES.
!         T = UPDATED integer POINTER ARRAY.

    implicit none

    logical :: HPFUN
    real (wp) :: XNODE(1),DATA(1)
    integer :: T(1)
    integer :: NMAX, NWDS, N, I, IPJ, J, J2, JL, JR

    if (N == NMAX) return 
    N=N+1
    J= T(N)-1
    do 1 I= 1,NWDS
        IPJ=I+J
        DATA(IPJ) = XNODE(I)
    1 end do
    J=N
    2 continue
    if (J == 1) return 
    JR=T(J)
    J2=J/2
    JL=T(J2)
    if (HPFUN(DATA(JL),DATA(JR),NWDS)) return 
    T(J2)=T(J)
    T(J)=JL
    J=J2
    GO TO 2

    end subroutine HPINS


    function LESS(A,B,NWDS)

    implicit none

    logical :: LESS
    integer :: NWDS
    real (wp), dimension(NWDS) :: A, B

    LESS= A(1) < B(1)
    return 

    end function LESS


    subroutine LQM0(F,U,V,RES8,EST)



!      PURPOSE
!           TO COMPUTE - IF = INTEGRAL OF F OVER THE TRIANGLE
!           WITH VERTICES (U(1),V(1)),(U(2),V(2)),(U(3),V(3)), AND
!           ESTIMATE THE ERROR,
!                      - INTEGRAL OF ABS(F) OVER THIS TRIANGLE

!      CALLING SEQUENCE
!           CALL LQM0(F,U,V,RES11,EST)
!        PARAMETERS
!           F       - FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
!                     F(X,Y); THE ACTUAL NAME FOR F NEEDS TO BE
!                     DECLARED E X T E R N A L IN THE CALLING
!                     PROGRAM
!           U(1),U(2),U(3)- ABSCISSAE OF VERTICES
!           V(1),V(2),V(3)- ORDINATES OF VERTICES
!           RES6    - APPROXIMATION TO THE INTEGRAL IF, OBTAINED BY THE
!                     LYNESS AND JESPERSEN RULE OF DEGREE 6, USING
!                     12 POINTS
!           RES8   - APPROXIMATION TO THE INTEGRAL IF, OBTAINED BY THE
!                     LYNESS AND JESPERSEN RULE OF DEGREE 8,
!                     USING 16 POINTS
!           EST     - ESTIMATE OF THE ABSOLUTE ERROR
!           DRESC   - APPROXIMATION TO THE INTEGRAL OF ABS(F- IF/DJ),
!                     OBTAINED BY THE RULE OF DEGREE 6, AND USED FOR
!                     THE COMPUTATION OF EST

!      REMARKS
!           DATE OF LAST UPDATE : 10 APRIL 1984 O.W. RECHARD NBS

!           SUBROUTINES OR FUNCTIONS CALLED :
!                   - F (USER-SUPPLIED INTEGRAND FUNCTION)
!                   - R1MACH FOR MACHINE DEPENDENT INFORMATION

! .....................................................................

    implicit none

    real (wp) :: DJ,DF0,DRESC,EMACH,EST,F,F0, &
    RES6,RES8,U1,U2,U3,UFLOW,V1,V2,V3,W60,W80, &
    Z1,Z2,Z3,RESAB6
    real (wp) :: AMAX1,AMIN1,SQRT
    real (wp), dimension(3) :: U,V,X,Y
    real (wp), dimension(9) :: W,ZETA1,ZETA2
    real (wp), dimension(19) :: FV
    integer :: J,KOUNT,L


!            FIRST HOMOGENEOUS COORDINATES OF POINTS IN DEGREE-6
!            AND DEGREE-8 FORMULA, TAKEN WITH MULTIPLICITY 3
    DATA ZETA1(1),ZETA1(2),ZETA1(3),ZETA1(4),ZETA1(5),ZETA1(6),ZETA1(7 &
    ),ZETA1(8),ZETA1(9)/0.5014265096581342E+00, &
    &   0.8738219710169965E+00,0.6365024991213939E+00, &
    &   0.5314504984483216E-01,0.8141482341455413E-01, &
    &   0.8989055433659379E+00,0.6588613844964797E+00, &
    &   0.8394777409957211E-02,0.7284923929554041E+00/
!            SECOND HOMOGENEOUS COORDINATES OF POINTS IN DEGREE-6
!            AND DEGREE-8 FORMULA, TAKEN WITH MUNLTIPLICITY 3
    DATA ZETA2(1),ZETA2(2),ZETA2(3),ZETA2(4),ZETA2(5),ZETA2(6),ZETA2(7 &
    ),ZETA2(8),ZETA2(9)/0.2492867451709329E+00, &
    &   0.6308901449150177E-01,0.5314504984483216E-01, &
    &   0.6365024991213939E+00,0.4592925882927229E+00, &
    &   0.5054722831703103E-01,0.1705693077517601E+00, &
    &   0.7284923929554041E+00,0.8394777409957211E-02/
!           WEIGHTS OF MID-POINT OF TRIANGLE IN DEGREE-6
!           RESP. DEGREE-8 FORMULAE
    DATA W60/0.0E+00/
    DATA W80/0.1443156076777862E+00/
!           WEIGHTS IN DEGREE-6 AND DEGREE-8 RULE
    DATA W(1),W(2),W(3),W(4),W(5),W(6),W(7),W(8),W(9)/ &
    &   0.1167862757263407E+00,0.5084490637020547E-01, &
    &   0.8285107561839291E-01,0.8285107561839291E-01, &
    &   0.9509163426728497E-01,0.3245849762319813E-01, &
    &   0.1032173705347184E+00,0.2723031417443487E-01, &
    &   0.2723031417443487E-01/

!           LIST OF MAJOR VARIABLES
!           ----------------------
!           DJ      - AREA OF THE TRIANGLE
!           DRESC   - APPROXIMATION TO INTEGRAL OF
!                     ABS(F- IF/DJ)  OVER THE TRIANGLE
!           RESAB6  - APPROXIMATION TO INTEGRAL OF
!                     ABS(F) OVER THE TRIANGLE
!           X       - CARTESIAN ABSCISSAE OF THE INTEGRATION
!                     POINTS
!           Y       - CARTESIAN ORDINATES OF THE INTEGRATION
!                     POINTS
!           FV      - FUNCTION VALUES

!           COMPUTE DEGREE-6 AND DEGREE-8 RESULTS FOR IF/DJ AND
!           DEGREE-6 APPROXIMATION FOR ABS(F)

    EMACH = R1MACH(4)
    UFLOW = R1MACH(1)
    U1=U(1)
    U2=U(2)
    U3=U(3)
    V1=V(1)
    V2=V(2)
    V3=V(3)
    DJ = ABS(U1*V2-U2*V1-U1*V3+V1*U3+U2*V3-V2*U3)*0.5E+00
    F0 = F((U1+U2+U3)/3.0E+00,(V1+V2+V3)/3.0E+00)
    RES6 = F0*W60
    RESAB6 = ABS(F0)*W60
    FV(1) = F0
    KOUNT = 1
    RES8 = F0*W80
    do 50 J=1,9
        Z1 = ZETA1(J)
        Z2 = ZETA2(J)
        Z3 = 1.0E+00-Z1-Z2
        X(1) = Z1*U1+Z2*U2+Z3*U3
        Y(1) = Z1*V1+Z2*V2+Z3*V3
        X(2) = Z2*U1+Z3*U2+Z1*U3
        Y(2) = Z2*V1+Z3*V2+Z1*V3
        X(3) = Z3*U1+Z1*U2+Z2*U3
        Y(3) = Z3*V1+Z1*V2+Z2*V3
        if (J <= 4) then
            F0 = 0.0E+00
            DF0 = 0.0E+00
            do 10 L=1,3
                KOUNT = KOUNT+1
                FV(KOUNT) = F(X(L),Y(L))
                F0 = F0+FV(KOUNT)
                DF0 = DF0+ABS(FV(KOUNT))
            10 end do
            RES6 = RES6+F0*W(J)
            RESAB6 = RESAB6+DF0*W(J)
        else
            F0 = F(X(1),Y(1))+F(X(2),Y(2))+F(X(3),Y(3))
            RES8 = RES8+F0*W(J)
        end if
    50 end do

!           COMPUTE DEGREE-6 APPROXIMATION FOR THE INTEGRAL OF
!           ABS(F-IF/DJ)

    DRESC = ABS(FV(1)-RES6)*W60
    KOUNT = 2
    do 60 J=1,4
        DRESC = DRESC+(ABS(FV(KOUNT)-RES6)+ABS(FV(KOUNT+1)-RES6)+ABS( &
        FV(KOUNT+2)-RES6))*W(J)
        KOUNT = KOUNT+3
    60 end do

!           COMPUTE DEGREE-6 AND DEGREE-8 APPROXIMATIONS FOR IF,
!           AND ERROR ESTIMATE

    RES6 = RES6*DJ
    RES8 = RES8*DJ
    RESAB6 = RESAB6*DJ
    DRESC = DRESC*DJ
    EST = ABS(RES6-RES8)
    if (DRESC /= 0.0E+00) EST = AMAX1(EST,DRESC*AMIN1(1.0E+00,(20.0E+00 &
    *EST/DRESC)**1.5E+00))
    if (RESAB6 > UFLOW) EST = AMAX1(EMACH*RESAB6,EST)
    return 

    end subroutine LQM0


    subroutine LQM1(F,U,V,RES11,EST)



!      PURPOSE
!           TO COMPUTE - IF = INTEGRAL OF F OVER THE TRIANGLE
!           WITH VERTICES (U(1),V(1)),(U(2),V(2)),(U(3),V(3)), AND
!           ESTIMATE THE ERROR,
!                      - INTEGRAL OF ABS(F) OVER THIS TRIANGLE

!      CALLING SEQUENCE
!           CALL LQM1(F,U,V,RES11,EST)
!        PARAMETERS
!           F       - FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
!                     F(X,Y); THE ACTUAL NAME FOR F NEEDS TO BE
!                     DECLARED E X T E R N A L IN THE CALLING
!                     PROGRAM
!           U(1),U(2),U(3)- ABSCISSAE OF VERTICES
!           V(1),V(2),V(3)- ORDINATES OF VERTICES
!           RES9    - APPROXIMATION TO THE INTEGRAL IF, OBTAINED BY THE
!                     LYNESS AND JESPERSEN RULE OF DEGREE 9, USING
!                     19 POINTS
!           RES11   - APPROXIMATION TO THE INTEGRAL IF, OBTAINED BY THE
!                     LYNESS AND JESPERSEN RULE OF DEGREE 11,
!                     USING 28 POINTS
!           EST     - ESTIMATE OF THE ABSOLUTE ERROR
!           DRESC   - APPROXIMATION TO THE INTEGRAL OF ABS(F- IF/DJ),
!                     OBTAINED BY THE RULE OF DEGREE 9, AND USED FOR
!                     THE COMPUTATION OF EST

!      REMARKS
!           DATE OF LAST UPDATE : 18 JAN 1984 D. KAHANER NBS

!           SUBROUTINES OR FUNCTIONS CALLED :
!                   - F (USER-SUPPLIED INTEGRAND FUNCTION)
!                   - R1MACH FOR MACHINE DEPENDENT INFORMATION

! .....................................................................

    implicit none

    real (wp) :: DJ,DF0,DRESC,EMACH,EST,F,F0, &
    RES9,RES11,U1,U2,U3,UFLOW,V1,V2,V3,W90,W110, &
    Z1,Z2,Z3
    real (wp) :: AMAX1,AMIN1,SQRT
    real (wp) :: RESAB9
    real (wp), dimension(3) :: U,V,X,Y
    real (wp), dimension(15) :: W,ZETA1,ZETA2
    real (wp), dimension(19) :: FV
    integer :: J,KOUNT,L


!            FIRST HOMOGENEOUS COORDINATES OF POINTS IN DEGREE-9
!            AND DEGREE-11 FORMULA, TAKEN WITH MULTIPLICITY 3
    DATA ZETA1(1),ZETA1(2),ZETA1(3),ZETA1(4),ZETA1(5),ZETA1(6),ZETA1(7 &
    ),ZETA1(8),ZETA1(9),ZETA1(10),ZETA1(11),ZETA1(12),ZETA1(13), &
    ZETA1(14),ZETA1(15)/0.2063496160252593E-01,0.1258208170141290E+00, &
    &   0.6235929287619356E+00,0.9105409732110941E+00, &
    &   0.3683841205473626E-01,0.7411985987844980E+00, &
    &   0.9480217181434233E+00,0.8114249947041546E+00, &
    &   0.1072644996557060E-01,0.5853132347709715E+00, &
    &   0.1221843885990187E+00,0.4484167758913055E-01, &
    &   0.6779376548825902E+00,0.0E+00,0.8588702812826364E+00/
!            SECOND HOMOGENEOUS COORDINATES OF POINTS IN DEGREE-9
!            AND DEGREE-11 FORMULA, TAKEN WITH MUNLTIPLICITY 3
    DATA ZETA2(1),ZETA2(2),ZETA2(3),ZETA2(4),ZETA2(5),ZETA2(6),ZETA2(7 &
    ),ZETA2(8),ZETA2(9),ZETA2(10),ZETA2(11),ZETA2(12),ZETA2(13), &
    ZETA2(14),ZETA2(15)/0.4896825191987370E+00,0.4370895914929355E+00, &
    &   0.1882035356190322E+00,0.4472951339445297E-01, &
    &   0.7411985987844980E+00,0.3683841205473626E-01, &
    &   0.2598914092828833E-01,0.9428750264792270E-01, &
    &   0.4946367750172147E+00,0.2073433826145142E+00, &
    &   0.4389078057004907E+00,0.6779376548825902E+00, &
    &   0.4484167758913055E-01,0.8588702812826364E+00,0.0E+00/
!           WEIGHTS OF MID-POINT OF TRIANGLE IN DEGREE-9
!           RESP. DEGREE-11 FORMULAE
    DATA W90/0.9713579628279610E-01/
    DATA W110/0.8797730116222190E-01/
!           WEIGHTS IN DEGREE-9 AND DEGREE-11 RULE
    DATA W(1),W(2),W(3),W(4),W(5),W(6),W(7),W(8),W(9),W(10),W(11),W(12 &
    ),W(13),W(14),W(15)/0.3133470022713983E-01,0.7782754100477543E-01, &
    &   0.7964773892720910E-01,0.2557767565869810E-01, &
    &   0.4328353937728940E-01,0.4328353937728940E-01, &
    &   0.8744311553736190E-02,0.3808157199393533E-01, &
    &   0.1885544805613125E-01,0.7215969754474100E-01, &
    &   0.6932913870553720E-01,0.4105631542928860E-01, &
    &   0.4105631542928860E-01,0.7362383783300573E-02, &
    &   0.7362383783300573E-02/

!           LIST OF MAJOR VARIABLES
!           ----------------------
!           DJ      - AREA OF THE TRIANGLE
!           DRESC   - APPROXIMATION TO INTEGRAL OF
!                     ABS(F- IF/DJ)  OVER THE TRIANGLE
!           RESAB9  - APPROXIMATION TO INTEGRAL OF
!                     ABS(F) OVER THE TRIANGLE
!           X       - CARTESIAN ABSCISSAE OF THE INTEGRATION
!                     POINTS
!           Y       - CARTESIAN ORDINATES OF THE INTEGRATION
!                     POINTS
!           FV      - FUNCTION VALUES

!           COMPUTE DEGREE-9 AND DEGREE-11 RESULTS FOR IF/DJ AND
!           DEGREE-9 APPROXIMATION FOR ABS(F)

    EMACH = R1MACH(4)
    UFLOW = R1MACH(1)
    U1=U(1)
    U2=U(2)
    U3=U(3)
    V1=V(1)
    V2=V(2)
    V3=V(3)
    DJ = ABS(U1*V2-U2*V1-U1*V3+V1*U3+U2*V3-V2*U3)*0.5E+00
    F0 = F((U1+U2+U3)/3.0E+00,(V1+V2+V3)/3.0E+00)
    RES9 = F0*W90
    RESAB9 = ABS(F0)*W90
    FV(1) = F0
    KOUNT = 1
    RES11 = F0*W110
    do 50 J=1,15
        Z1 = ZETA1(J)
        Z2 = ZETA2(J)
        Z3 = 1.0E+00-Z1-Z2
        X(1) = Z1*U1+Z2*U2+Z3*U3
        Y(1) = Z1*V1+Z2*V2+Z3*V3
        X(2) = Z2*U1+Z3*U2+Z1*U3
        Y(2) = Z2*V1+Z3*V2+Z1*V3
        X(3) = Z3*U1+Z1*U2+Z2*U3
        Y(3) = Z3*V1+Z1*V2+Z2*V3
        if (J <= 6) then
            F0 = 0.0E+00
            DF0 = 0.0E+00
            do 10 L=1,3
                KOUNT = KOUNT+1
                FV(KOUNT) = F(X(L),Y(L))
                F0 = F0+FV(KOUNT)
                DF0 = DF0+ABS(FV(KOUNT))
            10 end do
            RES9 = RES9+F0*W(J)
            RESAB9 = RESAB9+DF0*W(J)
        else
            F0 = F(X(1),Y(1))+F(X(2),Y(2))+F(X(3),Y(3))
            RES11 = RES11+F0*W(J)
        end if
    50 end do

!           COMPUTE DEGREE-9 APPROXIMATION FOR THE INTEGRAL OF
!           ABS(F-IF/DJ)

    DRESC = ABS(FV(1)-RES9)*W90
    KOUNT = 2
    do 60 J=1,6
        DRESC = DRESC+(ABS(FV(KOUNT)-RES9)+ABS(FV(KOUNT+1)-RES9)+ABS( &
        FV(KOUNT+2)-RES9))*W(J)
        KOUNT = KOUNT+3
    60 end do

!           COMPUTE DEGREE-9 AND DEGREE-11 APPROXIMATIONS FOR IF,
!           AND ERROR ESTIMATE

    RES9 = RES9*DJ
    RES11 = RES11*DJ
    RESAB9 = RESAB9*DJ
    DRESC = DRESC*DJ
    EST = ABS(RES9-RES11)
    if (DRESC /= 0.0E+00) EST = AMAX1(EST,DRESC*AMIN1(1.0E+00,(20.0E+00 &
    *EST/DRESC)**1.5E+00))
    if (RESAB9 > UFLOW) EST = AMAX1(EMACH*RESAB9,EST)
    return 

    end subroutine LQM1


    subroutine tridv(node,node1,node2,coef,rank)

    implicit none

    real (wp) :: coef,coef1,temp
    real (wp), dimension(*) :: node,node1,node2
    integer :: rank, i, j
    real (wp), dimension(3) :: s
    integer, dimension(3) :: t

    coef1=1.0-coef
    s(1)=(node(3)-node(5))**2+(node(4)-node(6))**2
    s(2)=(node(5)-node(7))**2+(node(6)-node(8))**2
    s(3)=(node(3)-node(7))**2+(node(4)-node(8))**2
    t(1)=1
    t(2)=2
    t(3)=3
    do 10 i=1,2
        do 10 j=i+1,3
            if(s(i) < s(j)) then
                temp=t(i)
                t(i)=t(j)
                t(j)=temp
            end if
    10 end do
    if(t(rank) == 1)then
        node1(3)=coef*node(3)+coef1*node(5)
        node1(4)=coef*node(4)+coef1*node(6)
        node1(5)=node(5)
        node1(6)=node(6)
        node1(7)=node(7)
        node1(8)=node(8)
        node2(3)=node1(3)
        node2(4)=node1(4)
        node2(5)=node(7)
        node2(6)=node(8)
        node2(7)=node(3)
        node2(8)=node(4)
    else if(t(rank) == 2) then
        node1(3)=coef*node(5)+coef1*node(7)
        node1(4)=coef*node(6)+coef1*node(8)
        node1(5)=node(7)
        node1(6)=node(8)
        node1(7)=node(3)
        node1(8)=node(4)
        node2(3)=node1(3)
        node2(4)=node1(4)
        node2(5)=node(3)
        node2(6)=node(4)
        node2(7)=node(5)
        node2(8)=node(6)
    else
        node1(3)=coef*node(3)+coef1*node(7)
        node1(4)=coef*node(4)+coef1*node(8)
        node1(5)=node(3)
        node1(6)=node(4)
        node1(7)=node(5)
        node1(8)=node(6)
        node2(3)=node1(3)
        node2(4)=node1(4)
        node2(5)=node(5)
        node2(6)=node(6)
        node2(7)=node(7)
        node2(8)=node(8)
    end if
    node1(9)=coef*node(9)
    node2(9)=coef1*node(9)

    end subroutine tridv


! ECK R1MACH
    function R1MACH(I)

    implicit none

    integer :: I
    real (wp) :: B, X, R1MACH
!***BEGIN PROLOGUE  R1MACH
!***PURPOSE  Return floating point machine dependent constants.
!***LIBRARY   SLATEC
!***CATEGORY  R1
!***TYPE      SINGLE PRECISION (R1MACH-S, D1MACH-D)
!***KEYWORDS  MACHINE CONSTANTS
!***AUTHOR  Fox, P. A., (Bell Labs)
!           Hall, A. D., (Bell Labs)
!           Schryer, N. L., (Bell Labs)
!***DESCRIPTION
!
!   R1MACH can be used to obtain machine-dependent parameters for the
!   local machine environment.  It is a function subprogram with one
!   (input) argument, and can be referenced as follows:
!
!        A = R1MACH(I)
!
!   where I=1,...,5.  The (output) value of A above is determined by
!   the (input) value of I.  The results for various values of I are
!   discussed below.
!
!   R1MACH(1) = B**(EMIN-1), the smallest positive magnitude.
!   R1MACH(2) = B**EMAX*(1 - B**(-T)), the largest magnitude.
!   R1MACH(3) = B**(-T), the smallest relative spacing.
!   R1MACH(4) = B**(1-T), the largest relative spacing.
!   R1MACH(5) = LOG10(B)
!
!   Assume single precision numbers are represented in the T-digit,
!   base-B form
!
!              sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
!
!   where 0 .LE. X(I) .LT. B for I=1,...,T, 0 .LT. X(1), and
!   EMIN .LE. E .LE. EMAX.
!
!   The values of B, T, EMIN and EMAX are provided in I1MACH as
!   follows:
!   I1MACH(10) = B, the base.
!   I1MACH(11) = T, the number of base-B digits.
!   I1MACH(12) = EMIN, the smallest exponent E.
!   I1MACH(13) = EMAX, the largest exponent E.
!
!
!***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for
!                 a portable library, ACM Transactions on Mathematical
!                 Software 4, 2 (June 1978), pp. 177-188.
!***ROUTINES CALLED  XERMSG
!***REVISION HISTORY  (YYMMDD)
!   790101  DATE WRITTEN
!   960329  Modified for Fortran 90 (BE after suggestions by EG)      
!***END PROLOGUE  R1MACH
!      
    X = 1.0
    B = RADIX(X)
    select case (I)
        case (1)
            R1MACH = B**(MINEXPONENT(X)-1) ! the smallest positive magnitude.
        case (2)
            R1MACH = HUGE(X)               ! the largest magnitude.
        case (3)
            R1MACH = B**(-DIGITS(X))       ! the smallest relative spacing.
        case (4)
            R1MACH = B**(1-DIGITS(X))      ! the largest relative spacing.
        case (5)
            R1MACH = LOG10(B)
        case DEFAULT
            write (*, FMT = 9000)
            9000 FORMAT ('1ERROR    1 IN R1MACH - I OUT OF BOUNDS')
            STOP
    end select
    return 

    end function R1MACH


end module dtwodq_mod
